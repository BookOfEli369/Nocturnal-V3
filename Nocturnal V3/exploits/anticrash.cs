using Nocturnal.Settings;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;


namespace Nocturnal.Exploits
{
     class Anticrash
    {

       
        internal static string whitelist = "";
        //Thx to Autumn for telling me about constructors.

        public Anticrash(GameObject obj,VRCPlayer vrcplayer)
        {
            if (ConfigVars.meshp)
            {
                var Skindemeshrender = obj.GetComponentsInChildren<SkinnedMeshRenderer>(true);
                var meshrenders = obj.GetComponentsInChildren<MeshRenderer>(true);
                int maxmaterials = 0;
                for (int i = 0; i < meshrenders.Length; i++)
                    maxmaterials += meshrenders[i].materials.Length;

                if (meshrenders.Length > Settings.ConfigVars.maxmeshes)
                {
                    NocturnalC.Log($"User {vrcplayer._player.field_Private_APIUser_0.displayName} hiddien by anticrash (Meshes) Meshrenders:[{meshrenders.Length}] ");
                    return;
                }
                if (maxmaterials > 800)
                {
                    NocturnalC.Log($"User {vrcplayer._player.field_Private_APIUser_0.displayName} hiddien by anticrash (Meshes) Giagantic number of materials:[{maxmaterials}] ");
                    return;
                }
                if (Skindemeshrender.Length > Settings.ConfigVars.maxmeshes / 1.5f)
                {
                    NocturnalC.Log($"User {vrcplayer._player.field_Private_APIUser_0.displayName} hiddien by anticrash (Meshes) SkindeMeshRenders:[{Skindemeshrender.Length}] ");
                    return;
                }
                for (int i3 = 0; i3 < meshrenders.Length; i3++)
                {
                    if (meshrenders[i3].materials.Count < Settings.ConfigVars.maxmaterials)
                    {
                        var a = new List<Material>();
                        a.Add(new Material(Shader.Find("Standard")));
                        meshrenders[i3].materials = a.ToArray();
                    }
                }
                for (int i = 0; i < Skindemeshrender.Length; i++)
                {
                    if (i > 5) continue;
                    if (Skindemeshrender[i].materials.Length > Settings.ConfigVars.maxmaterials * 1.5f)
                    {
                        var a = new List<Material>();
                        a.Add(new Material(Shader.Find("Standard")));
                        Skindemeshrender[i].materials = a.ToArray();
                    }
                }
            }
              

            if (ConfigVars.verticiesp)
            {
                var Skindemeshrender = obj.GetComponentsInChildren<SkinnedMeshRenderer>(true);
                var meshrenders = obj.GetComponentsInChildren<MeshFilter>(true);
                int toinc = 0;
                try
                {
                    for (int i = 0; i < Skindemeshrender.Length; i++)
                    {
                        if (Skindemeshrender[i].sharedMesh.vertexCount > Settings.ConfigVars.maxverticies)
                            return;
                    }
                }
                catch { }
                try
                {
                    for (int i = 0; i < meshrenders.Length; i++)
                    {
                        toinc += meshrenders[i].sharedMesh.vertexCount;
                    }
                    if (toinc > Settings.ConfigVars.maxverticies)
                        return;
                }
                catch { }

            }



            if (ConfigVars.ShaderP)
            {
                var renders = obj.GetComponentsInChildren<Renderer>(true);
                for (int v = 0; v < renders.Length; v++)
                {
                    for (int i = 0; i < renders[v].materials.Length; i++)
                    {
                        bool isbadshader = false;

                        if (renders[v].materials[i].shader.name.Contains("crash") || renders[v].materials[i].shader.name.Contains("lag") || renders[v].materials[i].shader.name.Contains("Crash") || renders[v].materials[i].shader.name.Contains("Lag"))
                        {
                            if (renders[v].materials[i].shader.name != "Standard")
                                NocturnalC.Log($"Shader Replaced:[{ renders[v].materials[i].shader.name}] on: {renders[v].name}", "Anti Crash", ConsoleColor.Red, Settings.ConfigVars.logshaderstoconsole);
                            renders[v].materials[i].shader = Shader.Find("Standard");
                        }
                        var splited = Settings.Download_Files.shaderlist.Split(new string[] { "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
                        for (int i3 = 0; i3 < splited.Length; i3++)
                        {
                            var tobc = splited[i3].Trim();
                            if (tobc.Length > 3)
                            {
                                if (renders[v].materials[i].shader.name.Contains(tobc))
                                    isbadshader = true;

                            }
                        }
                        if (!isbadshader)
                        {
                            if (renders[v].materials[i].shader.name != "Standard")
                                NocturnalC.Log($"Shader Replaced:[{renders[v].materials[i].shader.name}] on: {renders[v].name}", "Anti Crash", ConsoleColor.Red, Settings.ConfigVars.logshaderstoconsole);
                            renders[v].materials[i].shader = Shader.Find("Standard");
                        }
                        if (renders[v].materials[i].shader.passCount > 6)
                        {
                            if (renders[v].materials[i].shader.name != "Standard")
                                NocturnalC.Log($"Shader Replaced:[{renders[v].materials[i].shader.name}] on: {renders[v].name}", "Anti Crash", ConsoleColor.Red, Settings.ConfigVars.logshaderstoconsole);
                            renders[v].materials[i].shader = Shader.Find("Standard");

                        }
                    }
                }
            }

            if (ConfigVars.particlep)
            {
                int particlescount = 0;
                var pcount = obj.GetComponentsInChildren<ParticleSystem>(true);
                for (int i = 0; i < pcount.Length; i++)
                {
                    if (pcount[i].maxParticles > Settings.ConfigVars.maxparticles)
                    {
                        pcount[i].maxParticles = 0;
                    }
                }
                for (int i = 0; i < pcount.Length; i++)
                {
                    if (pcount[i].emissionRate > 99)
                    {
                        pcount[i].emissionRate = 0;
                    }
                }
                if (pcount.Length > Settings.ConfigVars.particlesystem)
                {
                    for (int i = 0; i < pcount.Length; i++)
                        Component.DestroyImmediate(pcount[i]);
                }
                else
                if (pcount.Length != 0)
                {
                    for (int i = 0; i < pcount.Length; i++)
                        particlescount += pcount[i].particleCount;
                    if (particlescount > 50000)
                    {
                        for (int i = 0; i < pcount.Length; i++)
                            Component.DestroyImmediate(pcount[i]);
                    }
                }
            }
              





            if (ConfigVars.linerenderp)
            {
                var linerenders = obj.GetComponentsInChildren<LineRenderer>(true);
                if (linerenders.Length > 49)
                {
                    for (int i = 0; i < linerenders.Length; i++)
                        Component.DestroyImmediate(linerenders[i]);
                    return;
                }
                for (int i = 0; i < linerenders.Length; i++)
                {
                    if (linerenders[i].positionCount > 20)
                    {
                        Component.DestroyImmediate(linerenders[i]);
                    }
                }
            }




            if (ConfigVars.lightsp)
            {
                var lights = obj.GetComponentsInChildren<Light>(true);
                if (lights.Length > 15)
                {
                    for (int i = 0; i < lights.Length; i++)
                        Component.DestroyImmediate(lights[i]);
                }
            }



            if (ConfigVars.audiosourcep)
            {
                var audiosources = obj.GetComponentsInChildren<AudioSource>(true);
                var audiofiltre = obj.GetComponentsInChildren<AvatarAudioSourceFilter>(true);
                if (audiofiltre.Length > Settings.ConfigVars.maxaudiosources)
                {
                    for (int i = 0; i < audiofiltre.Length; i++)
                        Component.DestroyImmediate(audiofiltre[i]);
                }
                if (audiosources.Length > Settings.ConfigVars.maxaudiosources)
                {
                    for (int i = 0; i < audiosources.Length; i++)
                        Component.DestroyImmediate(audiosources[i]);
                    return;
                }
                for (int i = 0; i < audiosources.Length; i++)
                    if (audiosources[i].clip == null)
                        Component.DestroyImmediate(audiosources[i]);
            }

            obj.SetActive(true);



        }












    }
}
